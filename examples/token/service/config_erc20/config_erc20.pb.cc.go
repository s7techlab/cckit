// Code generated by protoc-gen-cc-gateway. DO NOT EDIT.
// source: token/service/config_erc20/config_erc20.proto

/*
Package config_erc20 contains
  *   chaincode methods names {service_name}Chaincode_{method_name}
  *   chaincode interface definition {service_name}Chaincode
  *   chaincode gateway definition {service_name}}Gateway
  *   chaincode service to cckit router registration func
*/
package config_erc20

import (
	context "context"
	_ "embed"
	errors "errors"

	cckit_gateway "github.com/s7techlab/cckit/gateway"
	cckit_router "github.com/s7techlab/cckit/router"
	cckit_defparam "github.com/s7techlab/cckit/router/param/defparam"
	cckit_sdk "github.com/s7techlab/cckit/sdk"
	"google.golang.org/protobuf/types/known/emptypb"
)

// ConfigERC20ServiceChaincode method names
const (

	// ConfigERC20ServiceChaincodeMethodPrefix allows to use multiple services with same method names in one chaincode
	ConfigERC20ServiceChaincodeMethodPrefix = ""

	ConfigERC20ServiceChaincode_GetName = ConfigERC20ServiceChaincodeMethodPrefix + "GetName"

	ConfigERC20ServiceChaincode_GetSymbol = ConfigERC20ServiceChaincodeMethodPrefix + "GetSymbol"

	ConfigERC20ServiceChaincode_GetDecimals = ConfigERC20ServiceChaincodeMethodPrefix + "GetDecimals"

	ConfigERC20ServiceChaincode_GetTotalSupply = ConfigERC20ServiceChaincodeMethodPrefix + "GetTotalSupply"
)

// ConfigERC20ServiceChaincode chaincode methods interface
type ConfigERC20ServiceChaincode interface {
	GetName(cckit_router.Context, *emptypb.Empty) (*NameResponse, error)

	GetSymbol(cckit_router.Context, *emptypb.Empty) (*SymbolResponse, error)

	GetDecimals(cckit_router.Context, *emptypb.Empty) (*DecimalsResponse, error)

	GetTotalSupply(cckit_router.Context, *emptypb.Empty) (*TotalSupplyResponse, error)
}

// RegisterConfigERC20ServiceChaincode registers service methods as chaincode router handlers
func RegisterConfigERC20ServiceChaincode(r *cckit_router.Group, cc ConfigERC20ServiceChaincode) error {

	r.Query(ConfigERC20ServiceChaincode_GetName,
		func(ctx cckit_router.Context) (interface{}, error) {
			return cc.GetName(ctx, ctx.Param().(*emptypb.Empty))
		},
		cckit_defparam.Proto(&emptypb.Empty{}))

	r.Query(ConfigERC20ServiceChaincode_GetSymbol,
		func(ctx cckit_router.Context) (interface{}, error) {
			return cc.GetSymbol(ctx, ctx.Param().(*emptypb.Empty))
		},
		cckit_defparam.Proto(&emptypb.Empty{}))

	r.Query(ConfigERC20ServiceChaincode_GetDecimals,
		func(ctx cckit_router.Context) (interface{}, error) {
			return cc.GetDecimals(ctx, ctx.Param().(*emptypb.Empty))
		},
		cckit_defparam.Proto(&emptypb.Empty{}))

	r.Query(ConfigERC20ServiceChaincode_GetTotalSupply,
		func(ctx cckit_router.Context) (interface{}, error) {
			return cc.GetTotalSupply(ctx, ctx.Param().(*emptypb.Empty))
		},
		cckit_defparam.Proto(&emptypb.Empty{}))

	return nil
}

//go:embed config_erc20.swagger.json
var ConfigERC20ServiceSwagger []byte

// NewConfigERC20ServiceGateway creates gateway to access chaincode method via chaincode service
func NewConfigERC20ServiceGateway(sdk cckit_sdk.SDK, channel, chaincode string, opts ...cckit_gateway.Opt) *ConfigERC20ServiceGateway {
	return NewConfigERC20ServiceGatewayFromInstance(
		cckit_gateway.NewChaincodeInstanceService(
			sdk,
			&cckit_gateway.ChaincodeLocator{Channel: channel, Chaincode: chaincode},
			opts...,
		))
}

func NewConfigERC20ServiceGatewayFromInstance(chaincodeInstance cckit_gateway.ChaincodeInstance) *ConfigERC20ServiceGateway {
	return &ConfigERC20ServiceGateway{
		ChaincodeInstance: chaincodeInstance,
	}
}

// gateway implementation
// gateway can be used as kind of SDK, GRPC or REST server ( via grpc-gateway or clay )
type ConfigERC20ServiceGateway struct {
	ChaincodeInstance cckit_gateway.ChaincodeInstance
}

func (c *ConfigERC20ServiceGateway) Invoker() cckit_gateway.ChaincodeInstanceInvoker {
	return cckit_gateway.NewChaincodeInstanceServiceInvoker(c.ChaincodeInstance)
}

// ServiceDef returns service definition
func (c *ConfigERC20ServiceGateway) ServiceDef() cckit_gateway.ServiceDef {
	return cckit_gateway.NewServiceDef(
		_ConfigERC20Service_serviceDesc.ServiceName,
		ConfigERC20ServiceSwagger,
		&_ConfigERC20Service_serviceDesc,
		c,
		RegisterConfigERC20ServiceHandlerFromEndpoint,
	)
}

func (c *ConfigERC20ServiceGateway) GetName(ctx context.Context, in *emptypb.Empty) (*NameResponse, error) {
	var inMsg interface{} = in
	if v, ok := inMsg.(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return nil, err
		}
	}

	if res, err := c.Invoker().Query(ctx, ConfigERC20ServiceChaincode_GetName, []interface{}{in}, &NameResponse{}); err != nil {
		return nil, err
	} else {
		return res.(*NameResponse), nil
	}
}

func (c *ConfigERC20ServiceGateway) GetSymbol(ctx context.Context, in *emptypb.Empty) (*SymbolResponse, error) {
	var inMsg interface{} = in
	if v, ok := inMsg.(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return nil, err
		}
	}

	if res, err := c.Invoker().Query(ctx, ConfigERC20ServiceChaincode_GetSymbol, []interface{}{in}, &SymbolResponse{}); err != nil {
		return nil, err
	} else {
		return res.(*SymbolResponse), nil
	}
}

func (c *ConfigERC20ServiceGateway) GetDecimals(ctx context.Context, in *emptypb.Empty) (*DecimalsResponse, error) {
	var inMsg interface{} = in
	if v, ok := inMsg.(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return nil, err
		}
	}

	if res, err := c.Invoker().Query(ctx, ConfigERC20ServiceChaincode_GetDecimals, []interface{}{in}, &DecimalsResponse{}); err != nil {
		return nil, err
	} else {
		return res.(*DecimalsResponse), nil
	}
}

func (c *ConfigERC20ServiceGateway) GetTotalSupply(ctx context.Context, in *emptypb.Empty) (*TotalSupplyResponse, error) {
	var inMsg interface{} = in
	if v, ok := inMsg.(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return nil, err
		}
	}

	if res, err := c.Invoker().Query(ctx, ConfigERC20ServiceChaincode_GetTotalSupply, []interface{}{in}, &TotalSupplyResponse{}); err != nil {
		return nil, err
	} else {
		return res.(*TotalSupplyResponse), nil
	}
}

// ConfigERC20ServiceChaincodeResolver interface for service resolver
type (
	ConfigERC20ServiceChaincodeResolver interface {
		Resolve(ctx cckit_router.Context) (ConfigERC20ServiceChaincode, error)
	}

	ConfigERC20ServiceChaincodeLocalResolver struct {
		service ConfigERC20ServiceChaincode
	}

	ConfigERC20ServiceChaincodeLocatorResolver struct {
		locatorResolver cckit_gateway.ChaincodeLocatorResolver
		service         ConfigERC20ServiceChaincode
	}
)

func NewConfigERC20ServiceChaincodeLocalResolver(service ConfigERC20ServiceChaincode) *ConfigERC20ServiceChaincodeLocalResolver {
	return &ConfigERC20ServiceChaincodeLocalResolver{
		service: service,
	}
}

func (r *ConfigERC20ServiceChaincodeLocalResolver) Resolve(ctx cckit_router.Context) (ConfigERC20ServiceChaincode, error) {
	if r.service == nil {
		return nil, errors.New("service not set for local chaincode resolver")
	}

	return r.service, nil
}

func NewConfigERC20ServiceChaincodeResolver(locatorResolver cckit_gateway.ChaincodeLocatorResolver) *ConfigERC20ServiceChaincodeLocatorResolver {
	return &ConfigERC20ServiceChaincodeLocatorResolver{
		locatorResolver: locatorResolver,
	}
}

func (r *ConfigERC20ServiceChaincodeLocatorResolver) Resolve(ctx cckit_router.Context) (ConfigERC20ServiceChaincode, error) {
	if r.service != nil {
		return r.service, nil
	}

	locator, err := r.locatorResolver(ctx, _ConfigERC20Service_serviceDesc.ServiceName)
	if err != nil {
		return nil, err
	}

	r.service = NewConfigERC20ServiceChaincodeStubInvoker(locator)
	return r.service, nil
}

type ConfigERC20ServiceChaincodeStubInvoker struct {
	Invoker cckit_gateway.ChaincodeStubInvoker
}

func NewConfigERC20ServiceChaincodeStubInvoker(locator *cckit_gateway.ChaincodeLocator) *ConfigERC20ServiceChaincodeStubInvoker {
	return &ConfigERC20ServiceChaincodeStubInvoker{
		Invoker: &cckit_gateway.LocatorChaincodeStubInvoker{Locator: locator},
	}
}

func (c *ConfigERC20ServiceChaincodeStubInvoker) GetName(ctx cckit_router.Context, in *emptypb.Empty) (*NameResponse, error) {

	var inMsg interface{} = in
	if v, ok := inMsg.(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return nil, err
		}
	}

	if res, err := c.Invoker.Query(ctx.Stub(), ConfigERC20ServiceChaincode_GetName, []interface{}{in}, &NameResponse{}); err != nil {
		return nil, err
	} else {
		return res.(*NameResponse), nil
	}

}

func (c *ConfigERC20ServiceChaincodeStubInvoker) GetSymbol(ctx cckit_router.Context, in *emptypb.Empty) (*SymbolResponse, error) {

	var inMsg interface{} = in
	if v, ok := inMsg.(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return nil, err
		}
	}

	if res, err := c.Invoker.Query(ctx.Stub(), ConfigERC20ServiceChaincode_GetSymbol, []interface{}{in}, &SymbolResponse{}); err != nil {
		return nil, err
	} else {
		return res.(*SymbolResponse), nil
	}

}

func (c *ConfigERC20ServiceChaincodeStubInvoker) GetDecimals(ctx cckit_router.Context, in *emptypb.Empty) (*DecimalsResponse, error) {

	var inMsg interface{} = in
	if v, ok := inMsg.(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return nil, err
		}
	}

	if res, err := c.Invoker.Query(ctx.Stub(), ConfigERC20ServiceChaincode_GetDecimals, []interface{}{in}, &DecimalsResponse{}); err != nil {
		return nil, err
	} else {
		return res.(*DecimalsResponse), nil
	}

}

func (c *ConfigERC20ServiceChaincodeStubInvoker) GetTotalSupply(ctx cckit_router.Context, in *emptypb.Empty) (*TotalSupplyResponse, error) {

	var inMsg interface{} = in
	if v, ok := inMsg.(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return nil, err
		}
	}

	if res, err := c.Invoker.Query(ctx.Stub(), ConfigERC20ServiceChaincode_GetTotalSupply, []interface{}{in}, &TotalSupplyResponse{}); err != nil {
		return nil, err
	} else {
		return res.(*TotalSupplyResponse), nil
	}

}
