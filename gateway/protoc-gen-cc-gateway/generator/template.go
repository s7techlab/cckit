package generator

import (
	"text/template"

	"github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway/descriptor"
)

type param struct {
	*descriptor.File
	Imports []descriptor.GoPackage
}

var (
	pkg = make(map[string]string)

	funcMap = template.FuncMap{
		"goTypeName":    goTypeName,
		"hasBindings":   hasBindings,
		"hasGetBinding": hasGetBinding,
	}

	headerTemplate = template.Must(template.New("header").Funcs(funcMap).Parse(`
// Code generated by protoc-gen-cc-gateway. DO NOT EDIT.
// source: {{ .GetName }}

/*
Package {{ .GoPkg.Name }} contains
  *   chaincode interface definition
  *   chaincode gateway definition
  *   chaincode service to cckit router registration func
*/
package {{ .GoPkg.Name }}
import (
    {{ range $i := .Imports }}{{ if $i.Standard }}{{ $i | printf "%s\n" }}{{ end }}{{ end }}

    {{ range $i := .Imports }}{{ if not $i.Standard }}{{ $i | printf "%s\n" }}{{ end }}{{ end }}
)
`))
)

var ccTemplate = template.Must(template.New("chaincode").Funcs(funcMap).Option().Parse(`
{{ range $svc := .Services }}
 
// {{ $svc.GetName }}Chaincode  method names
const (
{{ range $m := $svc.Methods }}
 {{ $svc.GetName }}Chaincode_{{ $m.GetName }} = "{{ $m.GetName }}"
{{ end }}
)


// {{ $svc.GetName }}Chaincode chaincode methods interface
type {{ $svc.GetName }}Chaincode interface {
{{ range $m := $svc.Methods }}
   {{ $m.GetName }} (cckit_router.Context, *{{$m.RequestType.GoType $m.Service.File.GoPkg.Path | goTypeName }}) (*{{ $m.ResponseType.GoType $m.Service.File.GoPkg.Path | goTypeName }}, error)
{{ end }}
}


// Register{{ $svc.GetName }}Chaincode registers service methods as chaincode router handlers
func Register{{ $svc.GetName }}Chaincode(r *cckit_router.Group, cc {{ $svc.GetName }}Chaincode) error {

    {{ range $m := $svc.Methods }}
    {{ $method := "Invoke"}}
    {{ if $m | hasGetBinding }}{{ $method = "Query"}}{{ end }}

 r.{{ $method }}( {{ $svc.GetName }}Chaincode_{{ $m.GetName }}, 
		func(ctx cckit_router.Context) (interface{}, error) {
			return cc.{{ $m.GetName }}(ctx, ctx.Param().(*{{$m.RequestType.GoType $m.Service.File.GoPkg.Path | goTypeName }}))
		},
		cckit_defparam.Proto(&{{$m.RequestType.GoType $m.Service.File.GoPkg.Path | goTypeName }}{}))

   {{ end }}

   return nil 
}
 
{{ end }}
`))

var gatewayTemplate = template.Must(template.New("gateway").Funcs(funcMap).Option().Parse(`
{{ range $svc := .Services }}

// New{{ $svc.GetName }}Gateway creates gateway to access chaincode method via chaincode service
func New{{ $svc.GetName }}Gateway(ccService cckit_ccservice.Chaincode, channel, chaincode string, opts ...cckit_gateway.Opt) *{{ $svc.GetName }}Gateway {
	return &{{ $svc.GetName }}Gateway{Gateway: cckit_gateway.NewChaincode(ccService, channel, chaincode, opts...)}
}

// {{ $svc.GetName }}ApiDef returns service definition
func {{ $svc.GetName }}ApiDef(service *{{ $svc.GetName }}Gateway) cckit_gateway.ServiceDef {
	return cckit_gateway.ServiceDef{
		Desc:                        &_{{ $svc.GetName }}_serviceDesc,
		Service:                     service,
		HandlerFromEndpointRegister: Register{{ $svc.GetName }}HandlerFromEndpoint,
	}
}

// gateway implementation
// gateway can be used as kind of SDK, GRPC or REST server ( via grpc-gateway or clay )
type {{ $svc.GetName }}Gateway struct {
	Gateway cckit_gateway.Chaincode
}

type ValidatorInterface interface {
  Validate() error
}

 {{ range $m := $svc.Methods }}
 {{ $method := "Invoke"}}
 {{ if $m | hasGetBinding }}{{ $method = "Query"}}{{ end }}

 func (c *{{ $svc.GetName }}Gateway) {{ $m.GetName }}(ctx context.Context, in *{{$m.RequestType.GoType $m.Service.File.GoPkg.Path | goTypeName }}) (*{{ $m.ResponseType.GoType $m.Service.File.GoPkg.Path | goTypeName }}, error) {
    var inMsg interface{} = in
    if v, ok := inMsg.(ValidatorInterface); ok {
       if err := v.Validate(); err != nil {
		return nil, err
	   } 
     }

    if res, err := c.Gateway.{{ $method }}(ctx, {{ $svc.GetName }}Chaincode_{{ $m.GetName }} , []interface{}{in}, &{{ $m.ResponseType.GoType $m.Service.File.GoPkg.Path | goTypeName }}{}); err != nil {
		return nil, err
	} else {
		return res.(*{{ $m.ResponseType.GoType $m.Service.File.GoPkg.Path | goTypeName }}), nil
	}
 }
 {{ end }}

{{ end }}
`))
